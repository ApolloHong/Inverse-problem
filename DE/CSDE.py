import random
import numpy as np
from scipy.optimize import differential_evolution


def ex1():
    # Define the fitness function to be optimized
    def fitness(x):
        return x**2

    # Set the algorithm parameters
    bounds = [(-5, 5) for i in range(10)]
    maxiter = 1000
    strategy = 'best1bin'
    popsize = 50

    # Call the Cuckoo Search algorithm
    result = differential_evolution(fitness, bounds, strategy=strategy, maxiter=maxiter, popsize=popsize)

    print("Best solution found: ", result.x)
    print("Fitness value: ", result.fun)


def ex2():

    # Define the fitness function to be optimized
    def fitness(x):
        return np.sum(x ** 2)

    # Define the DE operator to combine two solutions and create a new one
    def de_operator(x1, x2, x3, F):
        return x1 + F * (x2 - x3)

    # Define the CS operator to generate a new solution using Lévy flight
    def cs_operator(x, alpha, lambda_, lower_bound, upper_bound):
        levy = lambda_ * np.random.standard_cauchy(len(x))
        new_x = x + alpha * levy / (abs(levy) ** (1 / 2))
        return np.clip(new_x, lower_bound, upper_bound)

    # Set the algorithm parameters
    pop_size = 50
    dim = 10
    max_iter = 1000
    F = 0.8
    cr = 0.7
    alpha = 0.1
    lambda_ = 1.5
    lower_bound = -5
    upper_bound = 5

    # Initialize the population with random solutions
    pop = np.random.uniform(low=lower_bound, high=upper_bound, size=(pop_size, dim))

    # Evaluate the fitness of each solution in the population
    fitness_values = np.array([fitness(x) for x in pop])

    # Main loop of the algorithm
    for i in range(max_iter):
        # Generate a new population by applying the DE and CS operators
        new_pop = np.zeros((pop_size, dim))
        for j in range(pop_size):
            # Select three solutions(index) from the population at random
            idxs = random.sample(range(pop_size), 3)
            x1, x2, x3 = pop[idxs]
            # Generate a new solution using the DE operator
            v = de_operator(x1, x2, x3, F)
            # Apply the CS operator to the new solution
            u = cs_operator(v, alpha, lambda_, lower_bound, upper_bound)
            # Replace one solution in the population if the new solution is better
            if fitness(u) < fitness_values[idxs[0]]:
                new_pop[j] = u
                fitness_values[idxs[0]] = fitness(u)
            else:
                new_pop[j] = pop[idxs[0]]
        pop = new_pop

        # Update the population with new solutions generated by Lévy flights
        for j in range(pop_size):
            # Generate a new solution using Lévy flight
            new_solution = cs_operator(pop[j], alpha, lambda_, lower_bound, upper_bound)
            # Replace the solution in the population if the new solution is better
            if fitness(new_solution) < fitness_values[j]:
                pop[j] = new_solution
                fitness_values[j] = fitness(new_solution)

    # Return the best solution found
    best_idx = np.argmin(fitness_values)
    best_solution = pop[best_idx]
    print("Best solution found: ", best_solution)
    print("Fitness value: ", fitness_values[best_idx])


def DE_CS_algorithm(fitness_func, bounds, pop_size=50, max_iter=1000, F=0.8, cr=0.7, step_size=0.1, pa=0.25, nest_num=50, alpha=1.5):
    """
    Implements a hybrid Differential Evolution (DE) and Cuckoo Search (CS) algorithm for optimization problems.

    Parameters:
    fitness_func (function): the fitness function to be optimized.
    bounds (tuple): the lower and upper bounds of the decision variables as a tuple of arrays.
    pop_size (int): the population size for the DE algorithm (default: 50).
    max_iter (int): the maximum number of iterations for the algorithm (default: 1000).
    F (float): the scaling factor for the DE algorithm (default: 0.8).
    cr (float): the crossover rate for the DE algorithm (default: 0.7).
    step_size (float): the step size for the CS algorithm (default: 0.1).
    pa (float): the probability of a cuckoo egg being discovered (default: 0.25).
    nest_num (int): the number of nests for the CS algorithm (default: 50).
    alpha (float): the power-law index for the Levy flight in the CS algorithm (default: 1.5).

    Returns:
    A tuple containing the best solution found and its fitness value.
    """

    # Define the fitness function to be optimized
    def fitness(x):
        return np.sum(x ** 2)

    # Define the DE operator to combine two solutions and create a new one
    def de_operator(x1, x2, x3, F):
        return x1 + F * (x2 - x3)

    # Define the CS operator to generate a new solution using Lévy flight
    def cs_operator(x, alpha, lambda_, lower_bound, upper_bound):
        levy = lambda_ * np.random.standard_cauchy(len(x))
        new_x = x + alpha * levy / (abs(levy) ** (1 / 2))
        return np.clip(new_x, lower_bound, upper_bound)

    # Set the bounds for the decision variables
    lower_bound, upper_bound = bounds

    # Initialize the population for the DE algorithm with random solutions
    pop = np.random.uniform(lower_bound, upper_bound, (pop_size, len(lower_bound)))

    # Evaluate the fitness of each solution in the population
    fitness_values = np.array([fitness_func(x) for x in pop])

    # Initialize the nests for the CS algorithm with random solutions
    nests = np.random.uniform(lower_bound, upper_bound, (nest_num, len(lower_bound)))

    # Evaluate the fitness of each nest in the population
    nest_fitness = np.array([fitness_func(x) for x in nests])

    # Main loop of the algorithm
    for i in range(max_iter):
        # Generate a new population for the DE algorithm by applying the DE operator
        new_pop = np.zeros_like(pop)
        for j in range(pop_size):
            # Select three solutions from the population at random
            idxs = np.random.choice(pop_size, 3, replace=False)
            x1, x2, x3 = pop[idxs]
            # Generate a new solution using the DE operator
            v = de_operator(x1, x2, x3, F, cr, lower_bound, upper_bound)
            # Evaluate the fitness of the new solution
            fv = fitness_func(v)
            # Choose the best solution between the new solution and the original solution
            if fv < fitness_values[j]:
                new_pop[j] = v
                fitness_values[j] = fv
            else:
                new_pop[j] = pop[j]
        pop = new_pop

        # Generate a new population for the CS algorithm by applying the CS operator
        new_nests = np.zeros_like(nests)
        for j, nest in enumerate(nests):
            # Generate a new solution using the Levy flight in the CS algorithm
            v = cs_operator(nest, step_size, lower_bound, upper_bound, alpha)
            # Evaluate the fitness of the new solution
            fv = fitness_func(v)
            # Choose the best solution between the new solution and the original solution
            if fv < nest_fitness[j]:
                new_nests[j] = x
                nest_fitness[j] = fv
            else:
                new_nests[j] = nest[j]

                # Sort the nests by fitness value
            sorted_idxs = np.argsort(nest_fitness)
            nest = new_nests[sorted_idxs]
            nest_fitness = nest_fitness[sorted_idxs]

            # Abandon a fraction of the nests and replace them with new ones
            # num_abandoned = int(abandon_rate * pop_size)
            num_abandoned = int(pa * pop_size)
            abandoned_nests = np.random.choice(pop_size, size=num_abandoned, replace=False)
            for j in abandoned_nests:
                nest[j] = np.random.randn(dim)
                nest_fitness[j] = fitness(nest[j])

            # Return the best solution found
        best_idx = np.argmin(nest_fitness)
        best_solution = nest[best_idx]
        return best_solution, nest_fitness[best_idx]

    # Set the algorithm parameters
    pop_size = 50
    dim = 10
    max_iter = 100
    F = 0.8
    cr = 0.7
    pa = 0.25
    abandon_rate = 0.25

    # Initialize the population with random solutions
    pop = np.random.randn(pop_size, dim)

    # Evaluate the fitness of each solution in the population
    fitness_values = np.array([fitness(x) for x in pop])

    # Main loop of the algorithm
    for i in range(max_iter):
        # Generate a new population by applying the DE and CS operators
        new_pop = np.zeros((pop_size, dim))
        for j in range(pop_size):
            # Select three solutions(index) from the population at random
            idxs = random.sample(range(pop_size), 3)
            x1, x2, x3 = pop[idxs]
            # Generate a new solution using the DE operator
            v = de_operator(x1, x2, x3, F, cr)
            # Apply the CS operator to the new solution
            u = cs_operator(v, pa)
            # Replace one solution in the population if the new solution is better
            if fitness(u) < fitness_values[idxs[0]]:
                new_pop[j] = u
                fitness_values[idxs[0]] = fitness(u)
            else:
                new_pop[j] = pop[idxs[0]]
        pop = new_pop

        # Run the CS algorithm on the current population
        best_solution, best_fitness = cuckoo_search(pop, fitness_values, max_iter=10, pa=pa, abandon_rate=abandon_rate)

        # Replace the worst solution in the population if the new solution is better
        worst_idx = np.argmax(fitness_values)
        if best_fitness < fitness_values[worst_idx]:
            pop[worst_idx] = best_solution
            fitness_values[worst_idx] = best_fitness

    # Return the best solution found
    best_idx = np.argmin(fitness_values)
    best_solution = pop[best_idx]
    print("Best solution found: ", best_solution)
    print("Fitness value: ", fitness_values[best_idx])



if __name__ == '__main__':
    pass